<!--***************************************************************************** -->
<!--* (c) Copyright Documentum, Inc. 2000-2001. All rights reserved. 		  -->
<!--* May not be used without prior written agreement signed 			  -->
<!--* by a Documentum corporate officer. 					  -->
<!-- Name: Config.dtd Version:4.2.5  Date:05/04/2001 				  -->
<!-- Description: 								  -->
<!-- This is the configuration dtd for XML Configuration Files in Documentum 	  -->
<!-- This DTD defines the rules of how you can automate the processing of XML     -->
<!-- Instances through library services in the eContent Repository                -->
<!-- DFC Operations for Import, Export, Checkin, Checkout use this for processing -->
<!-- XML Files									  -->
<!-- CHANGE NOTES:								  -->
<!-- Changed:UTK 05/04/2001 Improved Comments and layout 			  -->
<!--***************************************************************************** -->
<!--***************************************************************************** -->
<!-- reused content model in DTD -->
<!--***************************************************************************** -->
<!ENTITY % template-format "(#PCDATA| var)*">

<!--***************************************************************************** -->
<!-- Entity: map_rule_content.                                                    -->
<!-- Reusable list of elements 							  -->
<!--***************************************************************************** -->
<!ENTITY % map_rule_content " (variables?
			     , location?
                             , owner_name?
                             , object_name?
                             , acl_name?
                             , object_type?
                             , business_policy?
                             , metadata? )">

<!--*****************************************************************************-->
<!-- ELEMENT:application.                                                        -->
<!-- The application element is the root element in the configuration file for   -->
<!-- your application								 -->
<!--*****************************************************************************-->
<!ELEMENT application  (name , app_pattern , validation? , dds_validation? , map_rules )>

<!--***************************************************************************** -->
<!-- ELEMENT: name.                                                               -->
<!-- Name is a reused element for specify the name of your application, the name  -->
<!-- of documentum attributes to populate, and the name of a variable.   	  -->
<!-- The value of name is case sensitive when used for variables. 		  -->
<!-- When used in setting the application name you should make this the same 	  -->
<!-- name as your XML application (dm_xml_application) in Documentum.		  -->
<!--#USAGE: <name>CellPhoneCatalog</name> 					  -->
<!--***************************************************************************** -->
<!ELEMENT name  (#PCDATA )>

<!--***************************************************************************** -->
<!-- ELEMENT: app_pattern.                                                         -->
<!-- This is a container element for identifier information about the XML 	  -->
<!-- Application. This information is used for application detection.  	          -->
<!-- Currently, you must also specify this information in the dm_xml_application  -->
<!-- object's attributes. When an XML Instance is imported into Documentum this   -->
<!-- information is extracted and a query is performed against the		  -->
<!-- dm_xml_application objects to determine what applications can be used 	  -->
<!-- to process this document.  						  -->
<!--#USAGE: <app_pattern>						          -->
<!-- <sys_id>cellphone.dtd</sys_id>						  -->
<!-- <pub_id>-//Documentum//DTD CellPhoneInlineEntity//EN</pub_id>		  -->
<!-- <element>cellphone-catalog</element>				      	  -->
<!-- <element>model</element>							  -->
<!-- <element>description</element>						  -->
<!-- </app-pattern>								  -->
<!--***************************************************************************** -->
<!ELEMENT app_pattern  (sys_id? , pub_id? , element* )>

<!--***************************************************************************** -->
<!-- ELEMENT: sys_id.                                                              -->
<!-- The sys_id element specifies the DTD system identifier. The elements value   -->
<!-- should match the name of the dtd. Do not include path information. This      -->
<!-- should be the same as the dtd object name in the XML Application folder if   -->
<!-- you are managing your DTD witin Documentum. This should also match the       -->
<!-- sys_id on the dm_xml_application folder object of the XML Application. There -->
<!-- is currently no specific behaviour associated with this element.             -->
<!--#USAGE:<sys_id>cellphone.dtd</sys_id> 				 	  -->
<!--***************************************************************************** -->
<!ELEMENT sys_id  (#PCDATA )>

<!--***************************************************************************** -->
<!-- ELEMENT: pub_id.                                                              -->
<!-- The name of the public identifier if you are using public identifiers.       -->
<!-- This should also match the pub_id on the dm_xml_application folder object of -->
<!-- the XML Application. There is currently no specific behaviour associated with-->
<!-- this element. 								  -->
<!--#USAGE:<pub_id>-//Documentum//DTD CellPhoneInlineEntity//EN</pub_id>	  -->
<!--***************************************************************************** -->
<!ELEMENT pub_id  (#PCDATA )>

<!--***************************************************************************** -->
<!-- ELEMENT: element.                                                             -->
<!-- This is a reused content model. This element is the generic identifier or tag-->
<!-- name of an element. When used in app_pattern it is used to identify elements -->
<!-- that can be considered the root element in a document processed by the       -->
<!-- application. When used in element_selection_pattern it is to identify 	  -->
<!-- elements that trigger rules during processing. 				  -->
<!-- Attribute namespaceURI is the value of the URI part of a namespace that may  -->
<!-- be associated with the element.						  -->
<!--#USAGE: <element>cellphone-catalog</element> 				  -->
<!--***************************************************************************** -->
<!ELEMENT element  (#PCDATA )>
<!ATTLIST element  namespaceURI CDATA  #IMPLIED >

<!--***************************************************************************** -->
<!-- ELEMENT: validation.                                                          -->
<!-- The occurence of this element in your XML Configuration File means that you  -->
<!-- want to run the Parser in Validating Mode. If a DTD is stored in the XML     -->
<!-- Application Folder and referenced on the dm_xml_application folder object    -->
<!-- this will be used for validation. For Schema validation the URI address is   -->
<!-- used, and is not overriden by the occurence of a Schema in the XML 	  -->
<!-- Application Folder								  -->
<!--#USAGE:<validation/>							  -->
<!--***************************************************************************** -->
<!ELEMENT validation EMPTY>

<!--***************************************************************************** -->
<!-- ELEMENT: dds_validation.                                                       -->
<!-- The occurence of this element in your XML Application Configuration File will -->
<!-- run each object created/checked-in through the data dictionary                -->
<!-- validation.  You should only use this if you require added validation only met-->
<!-- by the data-dictionary facilities. 					   -->
<!-- There is a performance overhead associated with this.			   -->
<!--#USAGE:<dds_validation/>							   -->
<!--*****************************************************************************  -->
<!ELEMENT dds_validation EMPTY>

<!--***************************************************************************** -->
<!-- ELEMENT: map_rules.                                                           -->
<!-- This is a container element used to group each rule that determines how an   -->
<!-- XML Instance is processed in Documentum.					  -->
<!-- There are four types of map rules: xml_content_rule, link_rule, 		  -->
<!-- non_xml_content_rule, and entity_rule. 					  -->
<!-- Each Map Rule is triggered based on the element selection pattern in a rule. -->
<!-- There can only be one entity_rule.						  -->
<!-- Current Limitation: Each Rule must currently have a distinct element for	  -->
<!-- triggering. 								  -->
<!--#USAGE:<map_rules>								  -->
<!--	...									  -->
<!-- </map_rules>								  -->
<!--***************************************************************************** -->
<!ELEMENT map_rules  ( (xml_content_rule | link_rule | non_xml_content_rule )* ,  (entity_rule ,  (xml_content_rule | link_rule | non_xml_content_rule )* )? )>

<!--***************************************************************************** -->
<!-- ELEMENT: xml_content_rule.                                                    -->
<!-- This rule is mainly used for storing and creating XML content as objects in  -->
<!-- Documentum. The first part of the rule defines what in the XML content       -->
<!-- triggers the rule e.g. element occurence. The next part defines xml content  -->
<!-- to be extracted and used during processing, followed by how to create the    -->
<!-- object and what properties to set. This rule can also be used to capture     -->
<!-- variables and create folders/cabinets without creating an object 		  -->
<!-- corresponding to the element by setting attribute make_object="false".	  -->
<!--#USAGE:xml_content_rule 							  -->
<!-- Consider the example below: 						  -->
<!-- There are three attributes on the xml_content_rule - currently the only      -->
<!--  values supported for these are those listed. 				  -->
<!--										  -->
<!-- export: 									  -->
<!-- If an XML document is chunked across multiple    				  -->
<!-- objects and stored as a virtual document when you export or checkout that    -->
<!--  document a single XML instance will be created.				  -->
<!--										  -->
<!-- editable_virtual_doc:							  -->
<!-- Determine if editing is allowed in the virtual document manager. 		  -->
<!-- False is only current allowed value.			  		  -->
<!--										  -->
<!-- make_object:								  -->
<!-- This means do you want to create an object with this rule or    		  -->
<!-- is it just used for storing metadata for example to use on a subsequent rule.-->
<!-- If this attribute is not present then make_object is assumed true.	 Set it   -->
<!-- to false explicitly if you don't want the rule to create an object.	  -->
<!--										  -->
<!-- Next we have an element section pattern, this states that this rule is       -->
<!-- triggered when a description element is encountered while parsing an incoming-->
<!-- XML file.									  -->
<!--										  -->
<!-- Variables allow you to extract information from the incoming XML content     -->
<!-- and store it to use during processing e.g. setting metadata values.	  -->
<!-- Variables are locally scoped based on the element context, for example in    -->
<!-- this example any variables extracted in description can be used while setting-->
<!-- values of objects that were created from child elements of descriptions.     -->
<!-- Once the description element ends the variables are no longer available.     -->
<!-- It is always very important to consider the structure of your XML files when -->
<!-- setting up rules and especially for variable processing.			  -->
<!-- 										  -->
<!-- Location specifies what folder or cabinet this new object should be stored   -->
<!-- in. Variables can be used to create dynamic folder structures. Both relative -->
<!-- and full paths can be specified.  If a relative path is specified it will be -->
<!-- relative to the primary folder of the object that corresponds to next direct -->
<!-- element ancestor that created a chunk. If there is no parent chunk 	  -->
<!-- (i.e. this is the parent) then it will be the cabinet/folder selected on the -->
<!-- import operation.								  -->
<!--									          -->
<!-- Object_name specifies the object_name to be used. Again variables can be used-->
<!-- along with static text.							  -->
<!-- 										  -->
<!-- Object_type specifies what object-type should be used.  If this is not       -->
<!-- specified then dm_document will be used.				          -->
<!-- 										  -->
<!-- Metadata allows you to set both single value and repeating values of         -->
<!-- metadata.									  -->
<!--										  -->
<!-- Business Policies (life-cycles) and ACLS can also be specified.		  -->
<!-- 										  -->
<!-- <make_entity> and <link_template> specify how chunks are related by XML 	  -->
<!-- syntax. We recommend that you use make_entity here, this has the most        -->
<!-- support associated with it and supports retrieving a single XML instance from-->
<!-- multiple objects.								  -->
<!-- Using link_template allows you to specify that a link structure such as      -->
<!-- xlink, xinclude to use however links are not resolved inline on export/      -->
<!-- checkout currently. So export or checkout would result in multiple files.    -->
<!-- <xml_content_rule export="inline" editable_virtual_doc="false">
			<element_selection_pattern>
				<element>description</element>
			</element_selection_pattern>   
			<variables>
				<variable>
					<name>Desctitle</name>
					<content_of_element>
						<element_selection_pattern>
							<element>Title</element>
						</element_selection_pattern>
					</content_of_element>
					<default>Title Unspecified</default>
				</variable>
			</variables> 
			<location>
			<path>Descriptions/<var name="Desctitle"/></path>
			</location>
		 	<object_name><var name="Desctitle"/></object_name>    
			<object_type>dm_document</object_type>		
			<metadata>
				<dctmattr> 
					<name>title</name>
					<template><var name="Desctitle"/></template>
				</dctmattr>
			</metadata>   
			<make_entity/>
		</xml_content_rule>	-->
<!--*****************************************************************************-->
<!ELEMENT xml_content_rule  (element_selection_pattern ,  (%map_rule_content; ) ,  (make_entity | link_template ) )>
<!ATTLIST xml_content_rule  editable_virtual_doc  (false )  'false'
                            export                (inline )  'inline'
                            make_object           (true | false )  'true' >
                            
<!--*****************************************************************************-->
<!-- ELEMENT: link_rule.	                                                 -->
<!-- This rule instructs Documentum how to recognize and manage links (images,   -->
<!-- word docs)and NDATA entities for a given XML Application. 			 -->
<!--#USAGE:link_rule 								 -->
<!-- Consider the example below:						 -->
<!-- There are two attributes on the link_rule_element				 -->
<!-- peer_or_child means whether you want to manage the link using a Virtual     -->
<!-- Document Containment Link or a Relation Link				 -->
<!-- Most type of links such as images would be child links.  Please see the     -->
<!-- documentation for more detailed information on the differences.		 -->
<!-- NDATA means is this an NDATA entity reference. Notation names must 	 -->
<!-- match the format name of the object storing the ndata entity, i.e. server   -->
<!-- format name.								 -->
<!-- 										 -->
<!-- As with all rules the next section is the element_selection_pattern - this  -->
<!-- defines what in the xml triggers a link. In this example it is an image     -->
<!-- element. Link Target mean what in the selected element constitutes the link -->
<!-- target i.e. the file reference. In this example it is a href attribute.     -->
<!--										 -->
<!-- The rest of the rules are the same as the xml_content_rule, variables to    -->
<!-- gather, properties of object that the end of the link will be stored as.    -->
<!-- 										 -->
<!-- Note: There is no make_entity or link_template rule for this type of rule   -->
<!-- as the xml structure of the link was already defined in the incoming        -->
<!-- document.									 -->
<!-- Permanent Link sets the permanent lable on relation objects. This is only   -->
<!-- effective when the link type is peer. Please refer to the eContent Server   -->
<!-- Object Reference Manual for further information on relation objects.	 -->
<!--										 -->
<!-- Version Label defines the binding that is used on the containment or        -->
<!-- relation object - late binding is the default.				 -->
<!-- <link_rule peer_or_child="child" ndata="false">
			<element_selection_pattern>
				<element>image</element>
			</element_selection_pattern>          
			<link_target>
				<attr_name>href</attr_name>
			</link_target>        
			<variables>
				<variable>
					<name>ImgName</name>
					<content_of_element>
						<element_selection_pattern>
							<element>image</element>
						</element_selection_pattern>
					</content_of_element>
					<default>Title Unspecified</default>
				</variable>				
			</variables> 
			<location>
			<path>Images/<var name="ImgName"/></path>
			</location>
			<object_type>dm_document</object_type>
			<metadata>
				<dctmattr>
					<name>title</name>
					<template><var name="ImgName"/></template>
				</dctmattr>
		</metadata></link_rule> -->
<!--*****************************************************************************-->
<!ELEMENT link_rule  (element_selection_pattern , link_target ,  (%map_rule_content; ) , version_label? , permanent_link? )>
<!ATTLIST link_rule  peer_or_child  (peer | child )  'child'
                     ndata          (true | false )  'false' >
                     
<!--*****************************************************************************-->
<!-- ELEMENT: non_xml_content_rule.						 -->
<!-- This rule specifies how Documentum recognizes and manages non-XML           -->
<!-- content embedded in an XML instance, current support is for base64 encoded   -->
<!-- data.								 	 -->
<!--#USAGE:									 -->
<!-- Consider the example below:						 -->
<!-- element selection pattern specifies the element and what contains the       -->
<!-- encoded content.								 -->
<!-- element format_attr specifies the format type the resulting decoded data    -->
<!-- should be stored as in Documentum.	This should be the name of a valid format-->
<!-- object name.								 -->
<!-- link_template: specifies how this should be referenced from the parent xml  -->
<!-- object.									 -->
<!--<non_xml_content_rule>
    <element_selection_pattern>
        <element>mybase64</element>
    </element_selection_pattern>
    <format_attr>crtext</format_attr>
    <link_template>&lt;mybase64ref ref="<var name="location"/>"&gt;&lt;/mybase64ref&gt;</link_template>
</non_xml_content_rule> -->
<!--*****************************************************************************-->
<!ELEMENT non_xml_content_rule  (element_selection_pattern ,  (%map_rule_content; ) , format_attr , link_template )>
<!ATTLIST non_xml_content_rule  encoding  (base64 | text )  #FIXED 'base64' >

<!--*****************************************************************************-->
<!-- ELEMENT: entity_rule.							 -->
<!-- This rule instructs Documentum how to process Parsed entities.              -->
<!-- If this rule is not present parsed entities will be just considered as part -->
<!-- of the XML instance and the XML content will be processed according to the  -->
<!-- xml_content_rules. If this rule is present all parsed entities will be      -->
<!-- stored as separate objects and always maintained as parsed entities.        -->
<!-- Normally we would not expect users to use this rule if they are also        -->
<!-- using xml_content_rules for automatic chunking.				 -->
<!--#USAGE:									 -->
<!-- The entity rule currently has only two options what location to store       -->
<!-- parsed entities in and what object-type they should be stored as.		 -->
<!--*****************************************************************************-->
<!ELEMENT entity_rule  (location , object_type )>

<!--*****************************************************************************-->
<!-- ELEMENT: element_selection_pattern.					 -->
<!-- The element selection pattern element is a container element that is used   -->
<!-- to determine how different rules are triggered and also it is used within   -->
<!-- variable rules to determine what information to extract from the xml 	 -->
<!-- content.									 -->
<!--#USAGE:									 -->
<!-- Consider the example below:						 -->
<!-- This specifies to look for an element called chapter that belongs to        -->
<!-- namespaceURI "http://www.documentum.com/book.xsd"				 -->
<!-- who is a child of an element called book and who has an attribute called    -->
<!-- chapter_type with a value of introduction.					 -->
<!-- i.e. find an introduction chapter in book.					 -->
<!--    <element_selection_pattern>
        <element namespaceURI="http://www.documentum.com/book.xsd">chapter</element>
        <context_rule>
            <child_of>
                <element_selection_pattern>
                     <element>book</element>
                 </element_selection_pattern>
            </child_of>
         </context_rule>
         <attribute_test>
                <attr_name>chapter_type</attr_name>
                <value>introduction</value>
          </attribute_test>		
    </element_selection_pattern> -->
<!--*****************************************************************************-->
<!ELEMENT element_selection_pattern  (element , context_rule? , attribute_test* )>

<!--*****************************************************************************-->
<!-- ELEMENT: context_rule.							 -->
<!-- Context Rule defines the context in which an element occurs as part of      -->
<!-- selection criteria e.g. child of or descendent of 				 -->
<!--#USAGE:									 -->
<!-- 										 -->
<!-- Child_of means that the parent element is a certain element		 -->
<!-- Descendent_of means that any element in the hierarchy of this element is a  -->
<!-- certain element e.g. parent, grandparent, ..				 -->
<!-- <element_selection_pattern>
        <element namespaceURI="http://www.documentum.com/book.xsd">chapter</element>
        <context_rule>
            <child_of>
                <element_selection_pattern>
                     <element>book</element>
                 </element_selection_pattern>
            </child_of>
         </context_rule>
         <attribute_test>
                <attr_name>chapter_type</attr_name>
                <value>introduction</value>
          </attribute_test>		
    </element_selection_pattern> 						 -->
<!--*****************************************************************************-->
<!ELEMENT context_rule  (child_of | descendant_of )>

<!--*****************************************************************************-->
<!-- ELEMENT: child_of.								 -->
<!-- Child_of  - direct parent is a certain element 				 -->
<!--*****************************************************************************-->
<!ELEMENT child_of  (element_selection_pattern )>

<!--*****************************************************************************-->
<!-- ELEMENT: descendent_of.							 -->
<!-- descendent_of means any parent (parent, grandparent,..) is a certain element -->
<!--*****************************************************************************-->
<!ELEMENT descendant_of  (element_selection_pattern )>

<!--*****************************************************************************-->
<!-- ELEMENT: attribute_test.						         -->
<!-- Used by element selection_pattern to test whether a selected element has an -->
<!-- attribute equal to a certain value.  The attribute can be futher qualified  -->
<!-- using a namespaceURI.							 -->
<!--*****************************************************************************-->
<!ELEMENT attribute_test  (attr_name , value )>

<!--*****************************************************************************-->
<!-- ELEMENT: attr_name.								 -->
<!-- Name of attribute in an attribute test 					 -->
<!--*****************************************************************************-->
<!ELEMENT attr_name  (#PCDATA )>
<!ATTLIST attr_name  namespaceURI CDATA  #IMPLIED >

<!--*****************************************************************************-->
<!-- ELEMENT: value.								 -->
<!-- Value of an attribute in an attribute test 				 -->
<!--*****************************************************************************-->
<!ELEMENT value  (#PCDATA )>

<!--*****************************************************************************-->
<!-- ELEMENT: variables.							 -->
<!-- Container element for grouping all variable definitions/collectors in a     -->
<!-- mapping rule. 								 -->
<!--*****************************************************************************-->
<!ELEMENT variables  (variable+ )>

<!--*****************************************************************************-->
<!-- ELEMENT variable.								 -->
<!-- This allows the definition of a variable and what the value of the variable -->
<!-- is to be (e.g. attribute value, element content). The contents of the variable-->
<!-- can then be used for setting metadata and other properties during the       -->
<!-- processing of a rule. Variables are locally scoped based on the opening     -->
<!-- and closing of an element in which they are defined.			 -->
<!--#USAGE:									 -->
<!-- Consider the example below - here we are extracting the content of element  -->
<!-- model.name and storing as in a variable names modelName.			 -->
<!-- See var and template for usage of variables.				 -->
<!-- <variable>
	<name>modelName</name>
	<content_of_element>
	<element_selection_pattern>
		<element>model.name</element>
	</element_selection_pattern>
	</content_of_element>
	<default>Model Unspecified</default>
</variable> 									-->
<!--*****************************************************************************-->
<!ELEMENT variable  (name ,  (content_of_element | attribute_value_of_element | tagname_of_element ) , default? )>

<!--*****************************************************************************-->
<!-- ELEMENT: default.								 -->
<!-- This specifies the default value a variable will be assigned if its value is-->
<!-- not found in the XML instance. 						 -->
<!--*****************************************************************************-->
<!ELEMENT default  (#PCDATA )>

<!--*****************************************************************************-->
<!-- ELEMENT: content_of_element.						 -->
<!-- This specifies to get the content of an element. this_element means use the -->
<!-- content of the element in current context that is the element that triggered-->
<!-- the rule. Otherwise you can use an element selection pattern.               -->
<!--*****************************************************************************-->
<!ELEMENT content_of_element  (this_element | element_selection_pattern )>

<!--*****************************************************************************-->
<!-- ELEMENT: tagname_of_element.					         -->
<!-- This specifies to get the tagname of an element				 -->
<!--*****************************************************************************-->
<!ELEMENT tagname_of_element  (this_element | element_selection_pattern )>

<!--*****************************************************************************-->
<!-- ELEMENT: attribute_value_of_element.					 -->
<!-- This specifies to get the attribute value of an element. Use this_element   -->
<!-- to get an attribute value of the current element in context, i.e. the       -->
<!-- element that triggered the map rule.					 -->
<!--*****************************************************************************-->
<!ELEMENT attribute_value_of_element  ( (this_element | element_selection_pattern ) , attr_name )>

<!--*****************************************************************************-->
<!-- ELEMENT: this_element.							 -->
<!-- This element specifies to use the current element in context. The element 	 -->
<!-- that triggered the mapping rule.						 -->
<!--*****************************************************************************-->
<!ELEMENT this_element EMPTY>

<!--*****************************************************************************-->
<!-- ELEMENT: location.								 -->
<!-- This element defines what cabinet/folder an object is to be linked to.  If  -->
<!-- the folder path does not already exist, the folder will be created.         -->
<!-- Object-Type and Metadata on the folder object can be set.			 -->
<!--#USAGE:									 -->
<!-- In this example we are specifying a folder path Models/and a folder that is -->
<!-- created from the value of ModelName.					 -->
<!-- Note: the path is relative to the primary location of the parent chunk or   -->
<!-- in the case where it is the top-level chunk then to the folder specified    -->
<!-- through the operation e.g. users default cabinet or the cabinet/folder where-->
<!-- the document was imported to.						 -->
<!-- <location>	<path>Models/<var name="modelName"/></path></location> 		-->
<!--*****************************************************************************-->
<!ELEMENT location  (path , object_type? , metadata? )>

<!--*****************************************************************************-->
<!-- ELEMENT: path.								 -->
<!-- This rule defines the path of a cabinet/folder. The folder path can be      -->
<!-- dynamically created using variables set from the XML content. Relative and  -->
<!-- full-paths are supported. If this is not specified the new object will be   -->
<!-- linked to the folder of the parent chunk or in the case where there is no   -->
<!-- parent the location which the XML document was imported into.		 -->
<!--#USAGE:									 -->
<!--<path>Models/<var name="modelName"/></path>					 -->
<!--*****************************************************************************-->
<!ELEMENT path %template-format;>

<!--*****************************************************************************-->
<!-- ELEMENT: object_type.							 -->
<!-- This element specifies the object-type to be created. If this is not        -->
<!-- specified dm_document is used.						 -->
<!--*****************************************************************************-->
<!ELEMENT object_type %template-format;>

<!--*****************************************************************************-->
<!-- ELEMENT: metadata.								 -->
<!-- This is a container element for specifying how single valued and repeating  -->
<!-- metadata values are to be set on an object. 				 -->
<!--#USAGE:  									 -->
<!-- In the example below we are populating a number of attribute values using   -->
<!-- combinations of variables and static text.					 -->
<!-- <metadata>
	<dctmattr> 
	 <name>title</name>
	 <template><var name="brandName"/>-(model <var name="modelName"/>)-$<var name="price"/></template>
     </dctmattr>
     <dctmattr>
	<name>model_name</name>
	<template><var name="modelName"/></template>
 	</dctmattr>
	<dctmattr> 
	<name>brand_name</name>
	<template><var name="brandName"/></template>
	</dctmattr>
	<dctmattr> 
		<name>price</name>
		<template><var name="price"/></template>
	</dctmattr>
     </metadata> 								 -->
<!--*****************************************************************************-->
<!ELEMENT metadata  (dctmattr | dctmattr_repeating )+>

<!--*****************************************************************************-->
<!-- ELEMENT: dctmattr.								 -->
<!-- Element to allow single value attribute values to be set 			 -->
<!--#USAGE:  
        <dctmattr> 
		<name>price</name>
		<template><var name="price"/></template>
	</dctmattr>								 -->
<!--*****************************************************************************-->
<!ELEMENT dctmattr  (name , template )>

<!--*****************************************************************************-->
<!-- ELEMENT: dctmattr_repeating.						 -->
<!-- Element to allow repeating attribute values to be set.			 -->
<!--#USAGE:				
      <dctmattr_repeating>
                 <name>authors</name>
                 <template><var name="firstname"><var name="lastname">
       </dctmattr_repeating>							 -->
<!--										 -->
<!-- Note: In the example above we are populating each value of Authors with a   -->
<!-- combination of each occurence of firstname and lastname.  Each of these     -->
<!-- values is selected based on when they occur in the XML Instance.            -->
<!-- If you happened to have one author in your xml instance that only had a     -->
<!-- lastname this would cause the repeating attributes to be set with the wrong -->
<!-- combinations of firstname and lastname.					 -->
<!--*****************************************************************************-->
<!ELEMENT dctmattr_repeating  (name , template )>

<!--*****************************************************************************-->
<!-- ELEMENT: template.								 -->
<!-- This element allows you to combine variable values (var) and text to set    -->
<!-- properties of objects 							 -->
<!--#USAGE: <var name="firstname">						 -->
<!--*****************************************************************************-->
<!ELEMENT template %template-format;>

<!--*****************************************************************************-->
<!-- ELEMENT: owner_name.							 -->
<!-- This element allows you to set the owner name of the object. If the 	 -->
<!-- owner_name is not present, the name of the user who imports the document    -->
<!-- is used.									 -->
<!--*****************************************************************************-->
<!ELEMENT owner_name %template-format;>

<!--*****************************************************************************-->
<!-- ELEMENT: object_name.							 -->
<!-- This element allows you to set the object_name of an object.		 -->
<!--#USAGE:<object_name><var name="modelName"/></object_name> 									 -->
<!--*****************************************************************************-->
<!ELEMENT object_name %template-format;>

<!--*****************************************************************************-->
<!-- ELEMENT: acl_name.								 -->
<!-- This element allows you to set the acl of the object.  If this is not       -->
<!-- present default docbase security will be used.	Note: Only system ACLS   -->
<!-- can be specified.								 -->
<!--*****************************************************************************-->
<!ELEMENT acl_name %template-format;>

<!--*****************************************************************************-->
<!-- ELEMENT: business_policy.							-->
<!-- This element allows you to associate a business policy with an object.	-->
<!--#USAGE:									-->
<!--The business policy must already be created in the docbase that this XML    -->
<!-- Instance is being imported to.						-->
<!-- <business_policy>
	    <policy_name>/System/Applications/xFilesTest/Default XML Application/My Lifecycle2</policy_name>
	    <policy_scope>xFilesTest</policy_scope>
        <policy_state>Start</policy_state>
    </business_policy> -->
<!--*****************************************************************************-->
<!ELEMENT business_policy  (policy_name , policy_scope , policy_state )>

<!--*****************************************************************************-->
<!-- ELEMENT: policy_name. 							 -->
<!-- The name of the business policy 						 -->
<!--*****************************************************************************-->
<!ELEMENT policy_name %template-format;>

<!--*****************************************************************************-->
<!-- ELEMENT: policy_scope.							 -->
<!-- The scope of the business policy 						 -->
<!--*****************************************************************************-->
<!ELEMENT policy_scope %template-format;>

<!--*****************************************************************************-->
<!-- ELEMENT: policy_state.							 -->
<!-- The initial state of the policy 						 -->
<!--*****************************************************************************-->
<!ELEMENT policy_state %template-format;>

<!--*****************************************************************************-->
<!-- ELEMENT: version_label.							 -->
<!-- Version label to be used in link binding. Default is late binding           -->
<!--*****************************************************************************-->
<!ELEMENT version_label  (#PCDATA )>

<!--*****************************************************************************-->
<!-- ELEMENT: make_entity.							 -->
<!-- Specifies that a XML Chunk is maintained internally as an entity. 		 -->
<!--*****************************************************************************-->
<!ELEMENT make_entity EMPTY>

<!--*****************************************************************************-->
<!-- ELEMENT: link_template.							 -->
<!-- Specifies that an XML Chunk created using an XML_Content_Rule is managed    -->
<!-- using a definable link structure. This has currently limited support, does  -->
<!-- not support returning inline as a single instance.				 -->
<!--*****************************************************************************-->
<!ELEMENT link_template %template-format;>

<!--*****************************************************************************-->
<!-- ELEMENT: var.								 -->
<!-- Reference/Pointer to contents of a variable 				 -->
<!--*****************************************************************************-->
<!ELEMENT var EMPTY>
<!ATTLIST var  name CDATA  #REQUIRED >

<!--*****************************************************************************-->
<!-- ELEMENT: content_of_this_element.					         -->
<!-- Specifies that the element's content is to be considered the target of link -->
<!--*****************************************************************************-->
<!ELEMENT content_of_this_element EMPTY>

<!--*****************************************************************************-->
<!-- ELEMENT: link_target.							 -->
<!-- Specifies what attribute is to be considered the target of a link e.g. href -->
<!--*****************************************************************************-->
<!ELEMENT link_target  (attr_name|content_of_this_element)>

<!--*****************************************************************************-->
<!-- ELEMENT: permanent_link.					   		-->
<!-- Used with Relation objects. Sets Permanent Link to true. Please refer to   -->
<!-- eContent Server Object Reference manual for further information		-->
<!--*****************************************************************************-->
<!ELEMENT permanent_link EMPTY>

<!--*****************************************************************************-->
<!-- ELEMENT: format_attr.							 -->
<!-- Specifies the format's name, as specified in the format object, to be set.	 -->
<!-- This applies for an object whose content is set using    			 -->
<!-- a non_xml_content_rule e.g. base64 encoded content.  			 -->
<!--*****************************************************************************-->
<!ELEMENT format_attr  (#PCDATA )>
